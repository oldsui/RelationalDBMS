1. Basic information
Team number (e.g., 01) : 19
#1 Student ID : 10283095
#1 Student Name : Rui LIU
#2 Student ID : 20809476
#2 Student Name : Yue DING
OS (bit) : 64
gcc version : 4.8.5


2. Meta-data
- Show your meta-data design (Tables and Columns table) and information about each column.
Tables:
	   int	  |  varchar(50) |  varchar(50)
	table-id  |  table-name  |  file-name
	   1	  |  Tables	 |  Tables
	   2	  |  Columns	 |  Columns
     
Columns:
int		varchar(50)	int		int		int
table-id	column-name	column-type	column-length	column-position
1		table-id	TypeInt		4		1
1		table-name	TypeVarchar	50		2
1		file-name	TypeVarchar	50		3
2		table-id	TypeInt		4		1
2		column-name	TypeVarchar	50		2
2		column-type	TypeInt		4		3
2		column-length	TypeInt		4		4
2		column-position	TypeInt		4		5


3. Internal Record Format
Show your record format design and describe how your design satisfies O(1) field access. If not, just mention that your team hasn't implemented this feature.
	
The first 2 bytes(short) stores the field number of this record, and the next part also uses 2 bytes to store the corresponding offset of each field in this field. The third part stores the value of each field in this record. By doing so, when the record is touched, only if the field number is known, we can calculate the corresponding offset of that field and get access to its value (O(1)).

Describe how you store a VarChar field.


Describe how you deal with an update and delete.
We use the slot as a marker. The slot is composed of length of record and offset of record. 
If the record is deleted, we set the offset to -1. 
If the updated record is too large to be hold in the original page, we set the length to -1 showing the record is redirected to another page, and the old record is replaced with a new RID pointing to the redirected updated record.



4. Page Format
Show your page format design.
Page header:
{
    unsigned pageNumber;        // page number
    short recordCount;               // number of records on this page 
    short slotCount;                    // number of slots on this page
    short freeSpace;                  // size of free space
    short freeSpaceOffset;         // starting address of free space
    char misc[84];
} PageHeader;
Record 1  |   Record 2  | ……  |  Record n |
| Free space |
| slot n - 1  |  …. | slot 1 | slot 0 | 
Slot:
{
    short offset;                           // -1 for deleted records, tombstone
    short length;                          // -1 for redirected records, whose rid can be found by slot.offset
    unsigned char isRedirected;      // if this record is redirected from somewhere else, it's set to 					         non-zero value i; once marked, it's marked forever
} Slot;

Describe how you deal with an update and delete.
Update: first, we calculate the size of the new record, if the new size is smaller than the old record, we just shift the rest records to left of (old size - new size) amount of space, insert the new record and then and then we adjust the offset of this record as well as the rest records. If the updated record is the last one, no shifting needed.
If the new size is larger than the old record and the free space is enough to hold the new record, we shift the rest records to right of (new size - old size) amount of space, insert the new record and then and then we adjust the offset of this record as well as the rest records. If the updated record is the last one, no shifting needed.
If the new size is larger than the old record and the free space is not enough to hold the new record, we insert the updated record to another page, get the target RID and replace the old record with this RID, shift the rest records to left of (new size - RID size) amount of space, mark the RID.isRedirected as 1 to show it is redirected to somewhere, set this record slot length to -1 as a marker and then adjust the offset of the rest records. If the updated record is the last one, no shifting needed.
The free space offset is also updated accordingly.

Delete: we mark the corresponding slot offset to -1 to show this record is deleted. If the deleted record is not the last one, we shift the rest records to left of (record size) amount of space, and then we adjust the offset of the rest records. If the deleted record is the last one, no shifting needed.
The free space offset is also updated accordingly.

5. File Format
- Show your file format design
Heap file.

6. Implementation Detail
- Other implementation details goes here.


7. Other (optional)
- Freely use this section to tell us about things that are related to the project 2, but not related to the other sections (optional)

